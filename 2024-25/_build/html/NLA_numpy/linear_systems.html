
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Solving Linear Systems with Python &#8212; Statistical and Mathematical Methods for Machine Learning</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'NLA_numpy/linear_systems';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="A (very short) introduction to Machine Learning" href="../ML/intro_ML.html" />
    <link rel="prev" title="Visualization with Matplotlib" href="matplotlib.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Statistical and Mathematical Methods for Machine Learning - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Statistical and Mathematical Methods for Machine Learning - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Statistical and Mathematical Methods for Machine Learning (SMM)
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">NLA with Python</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="basics_python.html">Python Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction_to_numpy.html">Introduction to Python for NLA</a></li>
<li class="toctree-l1"><a class="reference internal" href="matplotlib.html">Visualization with Matplotlib</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Solving Linear Systems with Python</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Basics of Machine Learning</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../ML/intro_ML.html">A (very short) introduction to Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ML/SVD.html">Data Compression with Singular Value Decomposition (SVD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ML/PCA.html">Dimensionality Reduction with PCA</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Optimization</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Optimization/GD.html">Gradient Descent</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Optimization/SGD.html">Stochastic Gradient Descent</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Regression</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../regression_classification/regression.html">Regression</a></li>
<li class="toctree-l1"><a class="reference internal" href="../regression_classification/MLE_MAP.html">MLE and MAP</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Homeworks</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Homeworks/HW1.html">HW 1: Linear Algebra and Floating Point Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Homeworks/HW2.html">HW 2: SVD and PCA for Machine Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Homeworks/HW3.html">HW 3: Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Homeworks/HW4.html">HW 4: MLE/MAP</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/devangelista2/statistical-mathematical-methods" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/devangelista2/statistical-mathematical-methods/issues/new?title=Issue%20on%20page%20%2FNLA_numpy/linear_systems.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/NLA_numpy/linear_systems.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Solving Linear Systems with Python</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-the-accuracy">Testing the accuracy</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-test-problem">Creating a Test Problem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#condition-number">Condition number</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-linear-system-by-matrix-splitting">Solving Linear System by Matrix Splitting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cholesky-factorization">Cholesky factorization</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="solving-linear-systems-with-python">
<h1>Solving Linear Systems with Python<a class="headerlink" href="#solving-linear-systems-with-python" title="Link to this heading">#</a></h1>
<p>In the following we want to learn how to use <code class="docutils literal notranslate"><span class="pre">numpy</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy</span></code> to solve Linear Systems with Python. The majority of the functions in <code class="docutils literal notranslate"><span class="pre">numpy</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy</span></code> for Numerical Linear Algebra are contained in the sub-packages <code class="docutils literal notranslate"><span class="pre">np.linalg</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy.linalg</span></code>.</p>
<p>As a general rule, remember that <code class="docutils literal notranslate"><span class="pre">np.linalg</span></code> contains all the basic functions to run NLA algorithms, while <code class="docutils literal notranslate"><span class="pre">scipy</span></code> mostly focus on efficiency, implementing algorithms such as fast linear system solvers, memory efficiet matrix memorization, …</p>
<p>To fix the notation, consider a matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> and a vector <span class="math notranslate nohighlight">\(y \in \mathbb{R}^n\)</span>. <strong>Solving</strong> a linear system means finding (when exists) a vector <span class="math notranslate nohighlight">\(x \in \mathbb{R}^n\)</span> such that it satisfies</p>
<div class="math notranslate nohighlight">
\[
    Ax = y.
\]</div>
<p>Clearly, a trivial solution to this problem is to compute the inverse of <span class="math notranslate nohighlight">\(A\)</span> by using the function <code class="docutils literal notranslate"><span class="pre">np.linalg.inv()</span></code>, and then multiplying it by <span class="math notranslate nohighlight">\(y\)</span> to obtain the solution:</p>
<div class="math notranslate nohighlight">
\[
    x = A^{-1} y.
\]</div>
<p>However, we already remarked that this is unfeasible for large matrices <span class="math notranslate nohighlight">\(A\)</span>, since the computation of the inverse of a matrix requires <span class="math notranslate nohighlight">\(O(n!)\)</span> operations, which grows insanely fast.</p>
<blockquote>
<div><p><strong>Exercise:</strong> Implement a Python function taking as input a non-singular matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span>, a datum <span class="math notranslate nohighlight">\(y \in \mathbb{R}^n\)</span>, and returning the solution to the linear system <span class="math notranslate nohighlight">\(Ax = y\)</span>, by multiplying <span class="math notranslate nohighlight">\(A^{-1}\)</span> to <span class="math notranslate nohighlight">\(y\)</span>. This approach is usually referred to as <strong>direct solution</strong>. Check the time required to run this algorithm by defining the matrix <span class="math notranslate nohighlight">\(A\)</span> as a matrix of all ones with dimension <span class="math notranslate nohighlight">\(n \times n\)</span>, <span class="math notranslate nohighlight">\(y\)</span> being the vector of all ones, at increasing values of <span class="math notranslate nohighlight">\(n\)</span> from 1 to 30.</p>
</div></blockquote>
<p>As you can see from the exercise above, computing the solution to the linear system requires a lot of time even for relatively small matrices. The computational time required to solve the system can be lowered from <span class="math notranslate nohighlight">\(O(n!)\)</span> to <span class="math notranslate nohighlight">\(O(n^3)\)</span> by using a much efficient algorithm.</p>
<p>This is easy to do in <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, since it implements a function <code class="docutils literal notranslate"><span class="pre">np.linalg.solve</span></code>, taking as input a 2-dimensional array <code class="docutils literal notranslate"><span class="pre">A</span></code> and a 1-dimensional array <code class="docutils literal notranslate"><span class="pre">y</span></code>, and returning the solution <code class="docutils literal notranslate"><span class="pre">x</span></code> to the linear system. In particular:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Generates the problem</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c1"># Solve the system</span>
<span class="n">x_sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The solution is </span><span class="si">{</span><span class="n">x_sol</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The solution is [ 1. -1.  0.].
</pre></div>
</div>
</div>
</div>
<section id="testing-the-accuracy">
<h2>Testing the accuracy<a class="headerlink" href="#testing-the-accuracy" title="Link to this heading">#</a></h2>
<p>You should already know that a big limitation of any computational device is the <strong>floating point system</strong>. Indeed, the way of representing numbers by their mantissa+exponent decomposition, allows for a very efficient representation, but clearly not every floating point number is representable. For example, you already studied the concept of machine precision <span class="math notranslate nohighlight">\(\epsilon\)</span>, i.e. the smallest number such that</p>
<div class="math notranslate nohighlight">
\[
fl(1 + \epsilon) &gt; fl(1).
\]</div>
<p>As a consequence, a number such as <span class="math notranslate nohighlight">\(1 + \frac{\epsilon}{2}\)</span> cannot be represented by computers, since it is indistinguishable from 1.</p>
<p>This problem becomes particularly intense when one wants to encode real numbers such as <span class="math notranslate nohighlight">\(\pi\)</span> or the Nepero number <span class="math notranslate nohighlight">\(e\)</span>. Therefore, when we work with any algorithm which is implemented on a computational device, we always need to assume that the representation has some error. As a notation, we denote as <span class="math notranslate nohighlight">\(\tilde{A}\)</span> the machine representation of a matrix <span class="math notranslate nohighlight">\(A\)</span>, and by <span class="math notranslate nohighlight">\(\delta A := \tilde{A} - A\)</span> the representation error. The same notation applies for vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> representing the right-hand side of a linear system and its solution, respectively.</p>
<p>An important aspect of developing NLA algorithm is to study how representation errors in the measurement matrix <span class="math notranslate nohighlight">\(A\)</span> and known-term <span class="math notranslate nohighlight">\(y\)</span> gets <strong>amplified</strong> (or <strong>shrinked</strong>) in the solution <span class="math notranslate nohighlight">\(x\)</span> (i.e. to compute <span class="math notranslate nohighlight">\(\delta x\)</span> as a function of <span class="math notranslate nohighlight">\(\delta A\)</span> and <span class="math notranslate nohighlight">\(\delta y\)</span>). In particular, we usually care about the <strong>relative</strong> error, which is simpler to compute in most of the cases, and it does not depend on the measuring unit of the quantities.</p>
<p>In particular, the relative error between the true solution <span class="math notranslate nohighlight">\(x_{true}\)</span> and the computed solution <span class="math notranslate nohighlight">\(x_{sol}\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[
    E(x_{true}, x_{sol}) := \frac{|| x_{true} - x_{sol} ||_2}{|| x_{true} ||_2} = \frac{|| \delta x ||_2}{|| x_{true} ||_2}.
\]</div>
<p>However, to compute the relative error of a computed solution <span class="math notranslate nohighlight">\(x_{sol}\)</span>, we first need to know the <strong>true</strong> solution <span class="math notranslate nohighlight">\(x_{true}\)</span>, which is usually not the case in real scenario. How can be achieve it?</p>
<p>A common solution, which we will use for the whole course, is to verify the performance of the algorithm by building a <strong>test problem</strong>, i.e. a problem of which we know the true solution <em>by construction</em>.</p>
</section>
<section id="creating-a-test-problem">
<h2>Creating a Test Problem<a class="headerlink" href="#creating-a-test-problem" title="Link to this heading">#</a></h2>
<p>Consider a matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> and assume we want to test the accuracy of an algorithm solving systems involving <span class="math notranslate nohighlight">\(A\)</span>. Fix an <span class="math notranslate nohighlight">\(n\)</span>-dimensional vector <span class="math notranslate nohighlight">\(x_{true} \in \mathbb{R}^n\)</span>, and compute <span class="math notranslate nohighlight">\(y = Ax_{true}\)</span>. Clearly, this procedure defines a linear system</p>
<div class="math notranslate nohighlight">
\[
    Ax = y
\]</div>
<p>of which we know that <span class="math notranslate nohighlight">\(x_{true}\)</span> is a <strong>solution by construction</strong>, since we built the term <span class="math notranslate nohighlight">\(y\)</span> accordingly. Now, when we apply our algorithm to that linear system, we get a solution <span class="math notranslate nohighlight">\(x_{sol}\)</span>, which is in general different from <span class="math notranslate nohighlight">\(x_{true}\)</span> due to the amplification of the errors coming from the numerical representation of <span class="math notranslate nohighlight">\(A\)</span>. Since we defined the system such that <span class="math notranslate nohighlight">\(x_{true}\)</span> is the true solution, we can compute the relative error <span class="math notranslate nohighlight">\(E(x_{true}, x_{sol})\)</span> asssociated to the solution obtained by the algorithm, and quantify how the algorithm performed in terms of error amplification.</p>
<p>Let’s see how we can build a test problem in Python to test the accuracy of the classical linear system solver algorithm <code class="docutils literal notranslate"><span class="pre">np.linalg.solve</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Setting up the dimension</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">15</span>

<span class="c1"># Creating the test problem (with a Random matrix)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c1"># n x n random matrix</span>
<span class="n">x_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="p">))</span>   <span class="c1"># n-dimensional vector of ones</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x_true</span> <span class="c1"># Compute the term y s.t. x_true is a sol.</span>

<span class="c1"># Solving the system with numpy</span>
<span class="n">x_sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Computing the accuracy</span>
<span class="n">E_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_true</span> <span class="o">-</span> <span class="n">x_sol</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_true</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The relative error is </span><span class="si">{</span><span class="n">E_rel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The relative error is 1.9534625723042384e-14
</pre></div>
</div>
</div>
</div>
<p>As you can see, the error is very small. This is due to two aspects of the problem:</p>
<ol class="arabic simple">
<li><p>The algorithm is <strong>stable</strong> (i.e. it does not amplify the errors on <span class="math notranslate nohighlight">\(A\)</span>)</p></li>
<li><p>The matrix <span class="math notranslate nohighlight">\(A\)</span> il “well-behaved”, i.e. its inverse does not amplifies the errors on <span class="math notranslate nohighlight">\(y\)</span>. We say that <span class="math notranslate nohighlight">\(A\)</span> is <strong>well-conditioned</strong>, as opposed to <strong>ill-conditioned</strong> matrices.</p></li>
</ol>
<p>Let’s check what happens when we apply the same, stable algorithm, to solve a linear system where the matrix <span class="math notranslate nohighlight">\(A\)</span> is ill-conditioned, such as the <code class="docutils literal notranslate"><span class="pre">hilbert</span></code> matrix (available from the <code class="docutils literal notranslate"><span class="pre">scipy</span></code> package).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>

<span class="c1"># Setting up the dimension</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">15</span>

<span class="c1"># Creating the test problem (with Hilbert matrix)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># n x n hilbert matrix</span>
<span class="n">x_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="p">))</span>   <span class="c1"># n-dimensional vector of ones</span>

<span class="n">y</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x_true</span> <span class="c1"># Compute the term y s.t. x_true is a sol.</span>

<span class="c1"># Solving the system with numpy</span>
<span class="n">x_sol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Computing the accuracy</span>
<span class="n">E_rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_true</span> <span class="o">-</span> <span class="n">x_sol</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_true</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True solution: </span><span class="si">{</span><span class="n">x_true</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Computed solution: </span><span class="si">{</span><span class="n">x_sol</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The relative error is </span><span class="si">{</span><span class="n">E_rel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True solution: [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.].
Computed solution: [ 0.99999995  1.00000807  0.99967264  1.00577502  0.94490775  1.31657382
 -0.15652389  3.72666552 -3.00357812  4.04053468  1.3253252  -2.17033528
  4.1161354  -0.39618677  1.25102602].
The relative error is 1.9326759080352935
</pre></div>
</div>
</div>
</div>
<p>This example shows a fundamental concept in Numerical Linear Algebra: using a stable algorithm does <strong>NOT guarantee</strong> that that solution to the problem is accurate. Indeed, if the system matrix <span class="math notranslate nohighlight">\(A\)</span> is ill-conditioned, then there is <strong>no algorithm</strong> which is able to obtain an accurate solution.</p>
<p>In the following section, we investigate more in detail the meaning of conditioning of a linear operator.</p>
</section>
<section id="condition-number">
<h2>Condition number<a class="headerlink" href="#condition-number" title="Link to this heading">#</a></h2>
<p>When the matrix <span class="math notranslate nohighlight">\(A\)</span> is ill-conditioned, the solution of a linear system won’t be accurate, since the small perturbations on <span class="math notranslate nohighlight">\(y\)</span> introduced by the floating point system will be amplified and the corresponding solution will be drammatically distant to the true solution.</p>
<p>How can we quantify the conditioning of a matrix? And how we define a matrix to be ill-conditioned?</p>
<p>To quantify conditioning of an <span class="math notranslate nohighlight">\(n \times n\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, it is common to consider the <strong>condition number</strong> which, whenever <span class="math notranslate nohighlight">\(A\)</span> is invertible, is defined as:</p>
<div class="math notranslate nohighlight">
\[
    k_p(A) = ||A||_p || A^{-1} ||_p
\]</div>
<p>Where <span class="math notranslate nohighlight">\(p \geq 1\)</span> idenfities the norm on which the condition number is computed. Due to the equivalence of norms, the <strong>magnitude</strong> of the condition number does not depend of <span class="math notranslate nohighlight">\(p\)</span> (i.e. the magnitude of <span class="math notranslate nohighlight">\(k_p(A)\)</span> should be approximately the same, whatever is the value of <span class="math notranslate nohighlight">\(p\)</span>). For this reason, it is typical to measure the condition number of a matrix by setting <span class="math notranslate nohighlight">\(p=2\)</span>.</p>
<p>To compute the <span class="math notranslate nohighlight">\(p\)</span>-condition number of a matrix <span class="math notranslate nohighlight">\(A\)</span> in <code class="docutils literal notranslate"><span class="pre">numpy</span></code>, you can use the function <code class="docutils literal notranslate"><span class="pre">np.linalg.cond(A,</span> <span class="pre">p)</span></code>.</p>
<p>For example, let’s check the condition number of the random matrix vs the condition number of the hilbert matrix.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>

<span class="c1"># Setting up the dimension</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">15</span>

<span class="c1"># Creating the test problem (with Hilbert matrix)</span>
<span class="n">A_random</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="c1"># n x n random matrix</span>
<span class="n">A_hilbert</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="c1"># n x n hilbert matrix</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cond. Number Random matrix: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">A_random</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cond. Number Hilbert matrix: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">A_hilbert</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cond. Number Random matrix: 36.37470772865888
Cond. Number Hilbert matrix: 2.3228053763031325e+17
</pre></div>
</div>
</div>
</div>
<p>As you can see, the condition number of Hilbert matrix is insanely higher than the condition number of random matrix, which explains why the relative error while using the Hilbert matrix is higher than when using the random matrix.</p>
<p>Now, where do we set the threshold on the condition number to define an operator to be <strong>ill-conditioned</strong> versus it being <strong>well-conditioned</strong>? Let’s check an interesting property of the condition number.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We want to print out the condition number of the hilbert matrix A </span>
<span class="c1"># for increasing dimension</span>
<span class="n">n_max</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">condition_numbers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_max</span><span class="p">,</span> <span class="p">))</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Define the hilbert matrix</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Compute the condition number</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Print and save</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Condition number for n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="n">condition_numbers</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond</span> <span class="c1"># &quot;n-1&quot; because range begins by 1!</span>

<span class="c1"># Plot the condition number in semilogy plot</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">condition_numbers</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$k_2(A)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Condition number for n = 1: 1.0.
Condition number for n = 2: 19.281470067903967.
Condition number for n = 3: 524.0567775860627.
Condition number for n = 4: 15513.738738929662.
Condition number for n = 5: 476607.2502419222.
Condition number for n = 6: 14951058.641931808.
Condition number for n = 7: 475367356.51983196.
Condition number for n = 8: 15257576052.786306.
Condition number for n = 9: 493153909929.7127.
Condition number for n = 10: 16024897439077.97.
Condition number for n = 11: 521959222338558.8.
Condition number for n = 12: 1.6360718665566702e+16.
</pre></div>
</div>
<img alt="../_images/c2eb6b80a37e1ef73f877f664a9eb06b5c04755be0e8f61ea6ddd8ea8d0ae488.png" src="../_images/c2eb6b80a37e1ef73f877f664a9eb06b5c04755be0e8f61ea6ddd8ea8d0ae488.png" />
</div>
</div>
<p>As you can see, the condition number starts relatively small, then grows exponentially for increasing values of <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This is not a coincidence. Indeed, the condition number of basically every matrix <strong>grows with the dimensionality</strong>! As a consequence, the threshold defining an ill-conditioned matrix should depend on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This observation justifies the following definition:</p>
<blockquote>
<div><p>An invertible matrix <span class="math notranslate nohighlight">\(A\)</span> is said to be <strong>ill-conditioned</strong> if its condition number grows exponentially with the dimension of the problem, <span class="math notranslate nohighlight">\(n\)</span>, i.e. if <span class="math notranslate nohighlight">\(k_2(A) \approx c10^{n}\)</span> for a positive constant <span class="math notranslate nohighlight">\(c&gt;0\)</span>.</p>
</div></blockquote>
<p>While:</p>
<blockquote>
<div><p>An invertible matrix <span class="math notranslate nohighlight">\(A\)</span> is said to be <strong>well-conditioned</strong> if its condition number grows linearly with the dimension of the problem, <span class="math notranslate nohighlight">\(n\)</span>, i.e. if <span class="math notranslate nohighlight">\(k_2(A) \approx cn\)</span> for a positive constant <span class="math notranslate nohighlight">\(c&gt;0\)</span>.</p>
</div></blockquote>
<p>This can be checked by simply plotting the behavior of the condition number in <code class="docutils literal notranslate"><span class="pre">semilogy</span></code> scale. If the plot appears to be a straight line, then <span class="math notranslate nohighlight">\(A\)</span> is ill-conditioned, otherwise, it is well-conditioned.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># We want to print out the condition number of the hilbert matrix vs random matrix</span>
<span class="c1"># for increasing dimension</span>
<span class="n">n_max</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">condition_numbers_rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_max</span><span class="p">,</span> <span class="p">))</span>
<span class="n">condition_numbers_hilb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_max</span><span class="p">,</span> <span class="p">))</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Define the hilbert matrix</span>
    <span class="n">A_rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">A_hilb</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">hilbert</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Compute the condition number</span>
    <span class="n">cond_rand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">A_rand</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">cond_hilb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">A_hilb</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Print and save</span>
    <span class="n">condition_numbers_rand</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_rand</span> <span class="c1"># &quot;n-1&quot; because range begins by 1!</span>
    <span class="n">condition_numbers_hilb</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_hilb</span> <span class="c1"># &quot;n-1&quot; because range begins by 1!</span>

<span class="c1"># Plot the condition number in semilogy plot</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">condition_numbers_rand</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_max</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">condition_numbers_hilb</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$n$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;$\log k_2(A)$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;Random&quot;</span><span class="p">,</span> <span class="s2">&quot;Hilbert&quot;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2fc1c84f9674f303eff9f636bce41cd09b97897053f6a6c05081443844d4f400.png" src="../_images/2fc1c84f9674f303eff9f636bce41cd09b97897053f6a6c05081443844d4f400.png" />
</div>
</div>
<p>How can we relate the condition number of a matrix with the accuracy of the solution to a linear system associated with it?</p>
<p>Consider the following inequality:</p>
<div class="math notranslate nohighlight">
\[
    \frac{|| \delta x ||}{||x||} \leq k_2(A) \Bigl( \frac{||\delta A||}{|| A ||} + \frac{|| \delta y ||}{|| y ||} \Bigr).
\]</div>
<p>It implies that the relative error on the computed solution is big whenever <span class="math notranslate nohighlight">\(k_2(A)\)</span> is big. Moreover, note that as a consequence of the formula above, the accuracy of a computed solution is partially a proprierty of the condition number of <span class="math notranslate nohighlight">\(A\)</span> itself, meaning that (again) <strong>no algorithm</strong> is able to compute an accurate solution to an ill-conditioned system.</p>
</section>
<section id="solving-linear-system-by-matrix-splitting">
<h2>Solving Linear System by Matrix Splitting<a class="headerlink" href="#solving-linear-system-by-matrix-splitting" title="Link to this heading">#</a></h2>
<p>As you should know, when the matrix <span class="math notranslate nohighlight">\(A\)</span> is unstructured, the linear system <span class="math notranslate nohighlight">\(Ax = y\)</span> can be efficiently solved by using <a class="reference external" href="https://en.wikipedia.org/wiki/LU_decomposition">LU Decomposition</a>. In particular, with Gaussian elimination algorithm, one can factorize any non-singular matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> into:</p>
<div class="math notranslate nohighlight">
\[
    A = PLU
\]</div>
<p>where <span class="math notranslate nohighlight">\(L \in \mathbb{R}^{n \times n}\)</span> is a lower-triangular matrix, <span class="math notranslate nohighlight">\(U \in \mathbb{R}^{n \times n}\)</span> is an upper-triangular matrix with all ones on the diagonal and <span class="math notranslate nohighlight">\(P \in \mathbb{R}^{n \times n}\)</span> is a permutation matrix (i.e. a matrix obtained by permutating the rows of the identity matrix). If the decomposition is computed without pivoting, the permutation matrix equals the identity. Note that the assumption that <span class="math notranslate nohighlight">\(A\)</span> is non-singular is not restrictive, since it is a necessary condition for the solvability of <span class="math notranslate nohighlight">\(Ax = y\)</span>.</p>
<p>Since <span class="math notranslate nohighlight">\(P\)</span> is an orthogonal matrix, <span class="math notranslate nohighlight">\(P^{-1} = P^T\)</span>, thus</p>
<div class="math notranslate nohighlight">
\[
    A = PLU \iff P^T A = LU
\]</div>
<p>Since linear systems of the form</p>
<div class="math notranslate nohighlight">
\[
    Lx = y \quad \text{ and } \quad Ux = y
\]</div>
<p>can be efficiently solved by the Forward (Backward) substitution, and the computation of the LU factorization by Gaussian elimination is pretty fast (<span class="math notranslate nohighlight">\(O(n^3)\)</span> floating point operations), we can use that to solve the former linear system.</p>
<p>Indeed,</p>
<div class="math notranslate nohighlight">
\[
    Ax = y \iff P^TAx = P^Ty \iff LUx = P^Ty
\]</div>
<p>then, by Forward-Backward substitution, this system can be solved by subsequently solve</p>
<div class="math notranslate nohighlight">
\[
    Lz = P^Ty \quad \text{ then } \quad Ux = z
\]</div>
<p>whose solution is a solution for <span class="math notranslate nohighlight">\(Ax = y\)</span>.</p>
<p>Even if this procedure is automatically performed by the <code class="docutils literal notranslate"><span class="pre">np.linalg.solve</span></code> function, we can unroll it with the functions <code class="docutils literal notranslate"><span class="pre">scipy.linalg.lu(A)</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy.linalg.solve_triangular(A,</span> <span class="pre">b)</span></code>, whose documentation can be found <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lu.html">here</a> and <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve_triangular.html">here</a>.</p>
<blockquote>
<div><p><strong><em>Exercise:</em></strong> Write a function that takes as input a non-singular matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{n \times n}\)</span> and a vector <span class="math notranslate nohighlight">\(y \in \mathbb{R}^n\)</span> and returns the solution <span class="math notranslate nohighlight">\(x \in \mathbb{R}^n\)</span> of <span class="math notranslate nohighlight">\(Ax = y\)</span>, with the <code class="docutils literal notranslate"><span class="pre">np.linalg.solve</span></code> and the <code class="docutils literal notranslate"><span class="pre">scipy.linalg.lu()</span></code> + <code class="docutils literal notranslate"><span class="pre">scipy.linalg.solve_triangular()</span></code> functions. Compare the time required for the two algorithms when <span class="math notranslate nohighlight">\(A\)</span> is a random matrix of dimension <span class="math notranslate nohighlight">\(n = 1000\)</span>, while <span class="math notranslate nohighlight">\(y\)</span> is the datum built such that <span class="math notranslate nohighlight">\(x_{true}\)</span> is the vector of all ones. Check the reconstruction errors in the two cases.</p>
</div></blockquote>
</section>
<section id="cholesky-factorization">
<h2>Cholesky factorization<a class="headerlink" href="#cholesky-factorization" title="Link to this heading">#</a></h2>
<p>If the matrix <span class="math notranslate nohighlight">\(A\)</span> is SDP (symmetric and positive definite), then we can halve the number of operations required to compute the solution to the system by considering the Cholesky decomposition, which factorizes <span class="math notranslate nohighlight">\(AA\)</span> as:</p>
<div class="math notranslate nohighlight">
\[
A = L L^T
\]</div>
<p>where <span class="math notranslate nohighlight">\(L\)</span> is a non-singular lower-triangular matrix. Then, we can simply use the forward-backward algorithm to solve the system <span class="math notranslate nohighlight">\(Ax = y\)</span>.</p>
<p>The Cholesky decomposition can be computed in Python with the command <code class="docutils literal notranslate"><span class="pre">np.linalg.cholesky</span></code>.</p>
<p>Since it holds the following result:</p>
<blockquote>
<div><p><strong>Theorem:</strong> A square matrix <span class="math notranslate nohighlight">\(A\)</span> is SDP <strong>if and only if</strong> it admits a Cholesky decomposition,</p>
</div></blockquote>
<p>the function <code class="docutils literal notranslate"><span class="pre">np.linalg.cholesky</span></code> can be also used to check if a matrix <span class="math notranslate nohighlight">\(A\)</span> is SDP.</p>
<blockquote>
<div><p><strong>Exercise:</strong> Repeat the same exericise as before, setting <span class="math notranslate nohighlight">\(A\)</span> to be the Hilbert matrix, <span class="math notranslate nohighlight">\(n=10\)</span>, <span class="math notranslate nohighlight">\(x_{true}\)</span> is the vector of all ones. Check the accuracy and the time required by computing the solution with:</p>
<ul class="simple">
<li><p>The built-in <code class="docutils literal notranslate"><span class="pre">numpy</span></code> function.</p></li>
<li><p>The LU decomposition (with <code class="docutils literal notranslate"><span class="pre">scipy</span></code>) with <code class="docutils literal notranslate"><span class="pre">solve_triangular</span></code>.</p></li>
<li><p>The Cholesky decomposition with <code class="docutils literal notranslate"><span class="pre">solve_triangular</span></code>.</p></li>
</ul>
</div></blockquote>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./NLA_numpy"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="matplotlib.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Visualization with Matplotlib</p>
      </div>
    </a>
    <a class="right-next"
       href="../ML/intro_ML.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">A (very short) introduction to Machine Learning</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#testing-the-accuracy">Testing the accuracy</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-a-test-problem">Creating a Test Problem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#condition-number">Condition number</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-linear-system-by-matrix-splitting">Solving Linear System by Matrix Splitting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cholesky-factorization">Cholesky factorization</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Davide Evangelista
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>